"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2890],{3754:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"module-1-ros2/rclpy-for-control","title":"3. Writing Your First ROS 2 Node with rclpy","description":"Theory is great, but robotics is all about building things that work. In this chapter, we\'ll write our first ROS 2 nodes using rclpy, the official Python client library for ROS 2. We\'ll create a classic \\"talker\\" (publisher) and \\"listener\\" (subscriber) to see topics in action.","source":"@site/docs/module-1-ros2/3-rclpy-for-control.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/rclpy-for-control","permalink":"/physical-ai-book/docs/module-1-ros2/rclpy-for-control","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-book/physical-ai-book/tree/main/docs/module-1-ros2/3-rclpy-for-control.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"3. Writing Your First ROS 2 Node with rclpy","sidebar_label":"Controlling with rclpy","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Nodes, Topics, Services","permalink":"/physical-ai-book/docs/module-1-ros2/nodes-topics-services"},"next":{"title":"Humanoid URDF Models","permalink":"/physical-ai-book/docs/module-1-ros2/humanoid-urdf-models"}}');var r=s(4848),t=s(8453);const o={title:"3. Writing Your First ROS 2 Node with rclpy",sidebar_label:"Controlling with rclpy",sidebar_position:3},l="3. Hands-On: Writing Your First ROS 2 Node with rclpy",c={},a=[{value:"Setting Up Your ROS 2 Package",id:"setting-up-your-ros-2-package",level:2},{value:"Creating the Publisher Node (Talker)",id:"creating-the-publisher-node-talker",level:2},{value:"Code Breakdown",id:"code-breakdown",level:3},{value:"Creating the Subscriber Node (Listener)",id:"creating-the-subscriber-node-listener",level:2},{value:"Code Breakdown",id:"code-breakdown-1",level:3},{value:"Building and Running the Nodes",id:"building-and-running-the-nodes",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsxs)(n.h1,{id:"3-hands-on-writing-your-first-ros-2-node-with-rclpy",children:["3. Hands-On: Writing Your First ROS 2 Node with ",(0,r.jsx)(n.code,{children:"rclpy"})]})}),"\n",(0,r.jsxs)(n.p,{children:["Theory is great, but robotics is all about building things that work. In this chapter, we'll write our first ROS 2 nodes using ",(0,r.jsx)(n.code,{children:"rclpy"}),', the official Python client library for ROS 2. We\'ll create a classic "talker" (publisher) and "listener" (subscriber) to see topics in action.']}),"\n",(0,r.jsx)(n.h2,{id:"setting-up-your-ros-2-package",children:"Setting Up Your ROS 2 Package"}),"\n",(0,r.jsxs)(n.p,{children:["Before we write code, we need a place to put it. In ROS 2, code is organized into ",(0,r.jsx)(n.strong,{children:"packages"}),". Let's create one."]}),"\n",(0,r.jsx)(n.p,{children:"First, create a workspace directory to hold your packages:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Create a new directory for your ROS 2 workspace\nmkdir -p ~/ros2_ws/src\n\n# Navigate into the source directory\ncd ~/ros2_ws/src\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, use the ROS 2 command-line tools to create a new package. We'll call it ",(0,r.jsx)(n.code,{children:"py_pubsub"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Create a new Python package\nros2 pkg create --build-type ament_python py_pubsub --dependencies rclpy std_msgs\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This command creates a new directory named ",(0,r.jsx)(n.code,{children:"py_pubsub"})," with all the necessary files for a Python ROS 2 package, including ",(0,r.jsx)(n.code,{children:"package.xml"})," and ",(0,r.jsx)(n.code,{children:"setup.py"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"creating-the-publisher-node-talker",children:"Creating the Publisher Node (Talker)"}),"\n",(0,r.jsx)(n.p,{children:'Now let\'s write the code for our publisher node. This node will publish a "Hello, World" message with a counter to a topic every second.'}),"\n",(0,r.jsxs)(n.p,{children:["Create a new file inside your package: ",(0,r.jsx)(n.code,{children:"~/ros2_ws/src/py_pubsub/py_pubsub/publisher_node.py"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/py_pubsub/py_pubsub/publisher_node.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        # Create a publisher on the 'chatter' topic\n        self.publisher_ = self.create_publisher(String, 'chatter', 10)\n        # Create a timer that calls the timer_callback function every 1 second\n        timer_period = 1.0  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Hello World: {self.i}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n        self.i += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_publisher = MinimalPublisher()\n    rclpy.spin(minimal_publisher)\n    # Destroy the node explicitly\n    # (optional - otherwise it will be done automatically\n    # when the garbage collector destroys the node object)\n    minimal_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"code-breakdown",children:"Code Breakdown"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"import"})}),": We import ",(0,r.jsx)(n.code,{children:"rclpy"}),", the ",(0,r.jsx)(n.code,{children:"Node"})," class, and the ",(0,r.jsx)(n.code,{children:"String"})," message type from ",(0,r.jsx)(n.code,{children:"std_msgs.msg"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"MinimalPublisher"})," class"]}),": Our node is defined as a class that inherits from ",(0,r.jsx)(n.code,{children:"Node"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"__init__"})}),": In the constructor, we call the parent ",(0,r.jsx)(n.code,{children:"Node"})," constructor, giving our node the name ",(0,r.jsx)(n.code,{children:"'minimal_publisher'"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"create_publisher"})}),": This is the key line. We create a publisher that will send messages of type ",(0,r.jsx)(n.code,{children:"String"})," on a topic named ",(0,r.jsx)(n.code,{children:"'chatter'"}),". The ",(0,r.jsx)(n.code,{children:"10"})," is the queue size\u2014a quality of service (QoS) setting that limits the amount of queued messages if a subscriber is not receiving them fast enough."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"create_timer"})}),": We create a timer that will execute ",(0,r.jsx)(n.code,{children:"timer_callback"})," every ",(0,r.jsx)(n.code,{children:"1.0"})," seconds."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"timer_callback"})}),": This function is our main loop. It creates a ",(0,r.jsx)(n.code,{children:"String"})," message, populates its ",(0,r.jsx)(n.code,{children:"data"})," field, publishes it with ",(0,r.jsx)(n.code,{children:"self.publisher_.publish(msg)"}),", and logs it to the console."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"main"})," function"]}),": This is the standard entry point for a ROS 2 node. It initializes ",(0,r.jsx)(n.code,{children:"rclpy"}),", creates an instance of our node, and then calls ",(0,r.jsx)(n.code,{children:"rclpy.spin()"}),". ",(0,r.jsx)(n.code,{children:"spin()"})," is what keeps the node alive and processing callbacks (like our timer)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"creating-the-subscriber-node-listener",children:"Creating the Subscriber Node (Listener)"}),"\n",(0,r.jsxs)(n.p,{children:["Next, let's create the node that will listen to the ",(0,r.jsx)(n.code,{children:"'chatter'"})," topic."]}),"\n",(0,r.jsxs)(n.p,{children:["Create a new file: ",(0,r.jsx)(n.code,{children:"~/ros2_ws/src/py_pubsub/py_pubsub/subscriber_node.py"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# ~/ros2_ws/src/py_pubsub/py_pubsub/subscriber_node.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        # Create a subscriber on the 'chatter' topic\n        self.subscription = self.create_subscription(\n            String,\n            'chatter',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_subscriber = MinimalSubscriber()\n    rclpy.spin(minimal_subscriber)\n    minimal_subscriber.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"code-breakdown-1",children:"Code Breakdown"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"create_subscription"})}),": This is the subscriber equivalent of ",(0,r.jsx)(n.code,{children:"create_publisher"}),". We subscribe to the ",(0,r.jsx)(n.code,{children:"'chatter'"})," topic, expecting messages of type ",(0,r.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"self.listener_callback"})}),": This is the crucial part. We provide a callback function that will be executed every time a message is received on the topic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"listener_callback"})}),": This function receives the message object (",(0,r.jsx)(n.code,{children:"msg"}),") as its argument. Here, we simply log the contents of the message to the console."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"building-and-running-the-nodes",children:"Building and Running the Nodes"}),"\n",(0,r.jsx)(n.p,{children:"Before you can run the nodes, you need to:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Add entry points"})," to your ",(0,r.jsx)(n.code,{children:"setup.py"})," file so ROS 2 knows about your executables."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Build"})," your workspace."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Source"})," your workspace to make the new executables available."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"After following the steps in the official ROS 2 documentation for setting up your package, you can finally run the nodes."}),"\n",(0,r.jsxs)(n.p,{children:["Open two separate terminals. In both, make sure you have sourced your ROS 2 setup files (",(0,r.jsx)(n.code,{children:"source /opt/ros/humble/setup.bash"})," and ",(0,r.jsx)(n.code,{children:"source ~/ros2_ws/install/setup.bash"}),")."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"In Terminal 1, run the talker:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'ros2 run py_pubsub publisher_node\n# Expected output:\n# [INFO] [minimal_publisher]: Publishing: "Hello World: 0"\n# [INFO] [minimal_publisher]: Publishing: "Hello World: 1"\n# ...\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"In Terminal 2, run the listener:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'ros2 run py_pubsub subscriber_node\n# Expected output:\n# [INFO] [minimal_subscriber]: I heard: "Hello World: 0"\n# [INFO] [minimal_subscriber]: I heard: "Hello World: 1"\n# ...\n'})}),"\n",(0,r.jsx)(n.p,{children:"Congratulations! You have just created your first distributed robotic application with ROS 2. The publisher and subscriber are two completely separate programs communicating anonymously over a shared topic. This is the fundamental pattern you will use to build increasingly complex systems throughout this textbook."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);