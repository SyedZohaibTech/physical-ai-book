"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7133],{52:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-ros2/ai-agents-to-controllers","title":"5. From AI Agents to Robot Controllers","description":"We\'ve defined what our robot looks like with URDF, and we know how to write Python nodes with rclpy. Now, how do we command the robot to move?","source":"@site/docs/module-1-ros2/5-ai-agents-to-controllers.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/ai-agents-to-controllers","permalink":"/physical-ai-book/docs/module-1-ros2/ai-agents-to-controllers","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-book/physical-ai-book/tree/main/docs/module-1-ros2/5-ai-agents-to-controllers.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"5. From AI Agents to Robot Controllers","sidebar_label":"AI Agents to Controllers","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid URDF Models","permalink":"/physical-ai-book/docs/module-1-ros2/humanoid-urdf-models"},"next":{"title":"Exercises","permalink":"/physical-ai-book/docs/module-1-ros2/exercises"}}');var o=n(4848),i=n(8453);const r={title:"5. From AI Agents to Robot Controllers",sidebar_label:"AI Agents to Controllers",sidebar_position:5},l="5. Connecting AI Agents to Robot Controllers",a={},c=[{value:"A Simple &quot;AI Agent&quot;: The Joint State Publisher Node",id:"a-simple-ai-agent-the-joint-state-publisher-node",level:2},{value:"Code Breakdown",id:"code-breakdown",level:3},{value:"The Full Picture: From Agent to Visualization",id:"the-full-picture-from-agent-to-visualization",level:2}];function d(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"5-connecting-ai-agents-to-robot-controllers",children:"5. Connecting AI Agents to Robot Controllers"})}),"\n",(0,o.jsxs)(t.p,{children:["We've defined what our robot looks like with URDF, and we know how to write Python nodes with ",(0,o.jsx)(t.code,{children:"rclpy"}),". Now, how do we command the robot to move?"]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"robot_state_publisher"})," gets joint positions from the ",(0,o.jsx)(t.code,{children:"/joint_states"})," topic. This means that if we can publish messages to ",(0,o.jsx)(t.code,{children:"/joint_states"}),", we can control our robot's posture in RViz!"]}),"\n",(0,o.jsx)(t.p,{children:'This is the fundamental connection point between a high-level AI agent and the low-level control of a robot. An "AI Agent" (which could be a simple script, a reinforcement learning policy, or an LLM-based planner) makes a decision, and that decision is translated into a target joint angle that gets published to the robot\'s controllers.'}),"\n",(0,o.jsx)(t.h2,{id:"a-simple-ai-agent-the-joint-state-publisher-node",children:'A Simple "AI Agent": The Joint State Publisher Node'}),"\n",(0,o.jsx)(t.p,{children:'For now, our "AI Agent" will be a very simple Python node that publishes a sine wave motion to our arm joints. This will simulate a high-level agent sending dynamic commands to the robot.'}),"\n",(0,o.jsxs)(t.p,{children:["This node will publish ",(0,o.jsx)(t.code,{children:"sensor_msgs/msg/JointState"})," messages. This message type contains three arrays:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"name"}),": A list of joint names (e.g., ",(0,o.jsx)(t.code,{children:"['shoulder_joint', 'elbow_joint']"}),")."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"position"}),": A list of the corresponding joint angles in radians."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.code,{children:"velocity"}),": (Optional) A list of joint velocities."]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Let's create a new node in our ",(0,o.jsx)(t.code,{children:"py_pubsub"})," package."]}),"\n",(0,o.jsxs)(t.p,{children:["Create the file: ",(0,o.jsx)(t.code,{children:"~/ros2_ws/src/py_pubsub/py_pubsub/joint_publisher_node.py"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"# ~/ros2_ws/src/py_pubsub/py_pubsub/joint_publisher_node.py\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport math\n\nclass JointStatePublisher(Node):\n\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n        self.publisher_ = self.create_publisher(JointState, 'joint_states', 10)\n        timer_period = 0.1  # seconds (10 Hz)\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.get_logger().info('Joint State Publisher has been started.')\n        self.start_time = self.get_clock().now().seconds_nanoseconds()[0]\n\n    def timer_callback(self):\n        # Calculate the elapsed time\n        current_time = self.get_clock().now().seconds_nanoseconds()[0]\n        elapsed_time = float(current_time - self.start_time)\n\n        # Create a JointState message\n        joint_state_msg = JointState()\n        joint_state_msg.header = Header()\n        joint_state_msg.header.stamp = self.get_clock().now().to_msg()\n        \n        # Define the joint names from our URDF\n        joint_state_msg.name = ['shoulder_joint', 'elbow_joint']\n        \n        # Calculate new joint positions using a sine wave for smooth motion\n        # This simulates an \"AI\" decision loop\n        shoulder_angle = math.sin(elapsed_time * 0.5) # Slower oscillation for shoulder\n        elbow_angle = math.sin(elapsed_time * 1.0) # Faster oscillation for elbow\n        \n        joint_state_msg.position = [shoulder_angle, elbow_angle]\n        \n        # Publish the message\n        self.publisher_.publish(joint_state_msg)\n        # self.get_logger().info(f'Publishing joint states: {joint_state_msg.position}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_state_publisher = JointStatePublisher()\n    rclpy.spin(joint_state_publisher)\n    joint_state_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(t.h3,{id:"code-breakdown",children:"Code Breakdown"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"JointStatePublisher"})}),": A new node that publishes ",(0,o.jsx)(t.code,{children:"sensor_msgs/msg/JointState"})," messages."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"create_publisher"})}),": We create a publisher that sends ",(0,o.jsx)(t.code,{children:"JointState"})," messages to the ",(0,o.jsx)(t.code,{children:"/joint_states"})," topic. This is the exact topic that the ",(0,o.jsx)(t.code,{children:"robot_state_publisher"})," listens to."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:(0,o.jsx)(t.code,{children:"timer_callback"})}),": This function runs 10 times per second (10 Hz)."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Time Calculation"}),": We use the node's clock to get the elapsed time, which drives our sine wave function."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsxs)(t.strong,{children:[(0,o.jsx)(t.code,{children:"JointState"})," Message"]}),": We construct the message, making sure the ",(0,o.jsx)(t.code,{children:"name"})," array matches the joint names in our URDF file ",(0,o.jsx)(t.em,{children:"exactly"}),"."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Sine Wave"}),": We use ",(0,o.jsx)(t.code,{children:"math.sin()"})," to generate smooth, oscillating values for our joint angles. This is a common technique for creating simple, continuous motions and serves as a stand-in for a more complex AI agent's output."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Publish"}),": We publish the complete message."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"the-full-picture-from-agent-to-visualization",children:"The Full Picture: From Agent to Visualization"}),"\n",(0,o.jsx)(t.p,{children:"Now let's put all the pieces from this module together. To see our robot arm move, we need to run three things:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsxs)(t.strong,{children:["The ",(0,o.jsx)(t.code,{children:"robot_state_publisher"})]}),": This node reads our URDF and listens for joint states."]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsxs)(t.strong,{children:["Our ",(0,o.jsx)(t.code,{children:"joint_state_publisher_node"})]}),': Our new "AI agent" that publishes the target joint states.']}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"RViz"}),": The 3D visualization tool that subscribes to the TF2 data published by the ",(0,o.jsx)(t.code,{children:"robot_state_publisher"}),"."]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Here is the data flow:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-mermaid",children:"graph TD\n    subgraph Our Custom Node\n        A[joint_state_publisher_node]\n    end\n    \n    subgraph ROS 2 System\n        B(robot_state_publisher)\n        C(RViz)\n    end\n\n    A -- /joint_states --\x3e B;\n    B -- Reads --\x3e D{arm.urdf};\n    B -- /tf --\x3e C;\n"})}),"\n",(0,o.jsx)(t.p,{children:"When you run all these components (after building your package and sourcing the workspace), you will see the simple arm from the previous chapter waving in RViz!"}),"\n",(0,o.jsx)(t.p,{children:'This simple loop\u2014an "agent" publishing joint commands which are then visualized\u2014is the core of robot control. In later modules, we will replace our simple sine-wave publisher with much more intelligent nodes that can see the world, make decisions, and command the robot to perform complex tasks.'})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var s=n(6540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);