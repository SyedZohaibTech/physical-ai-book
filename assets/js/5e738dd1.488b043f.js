"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[274],{6833(n,i,e){e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module3/isaac-sim","title":"Isaac Sim for Humanoid Robotics","description":"Isaac Sim is NVIDIA\'s high-fidelity simulation environment built on the Omniverse platform, specifically designed for robotics applications. It provides photorealistic rendering, accurate physics simulation, and seamless integration with the ROS/ROS 2 ecosystem, making it ideal for developing complex humanoid robots.","source":"@site/docs/module3/isaac-sim.md","sourceDirName":"module3","slug":"/module3/isaac-sim","permalink":"/physical-ai-book/docs/module3/isaac-sim","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedZohaibTech/physical-ai-book/edit/main/docs/module3/isaac-sim.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Isaac Sim for Humanoid Robotics"},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to NVIDIA Isaac","permalink":"/physical-ai-book/docs/module3/introduction"},"next":{"title":"Isaac ROS Integration","permalink":"/physical-ai-book/docs/module3/isaac-ros"}}');var o=e(4848),t=e(8453);const a={sidebar_position:2,title:"Isaac Sim for Humanoid Robotics"},s="Isaac Sim for Humanoid Robotics",l={},c=[{value:"Overview of Isaac Sim",id:"overview-of-isaac-sim",level:2},{value:"Installation and Setup",id:"installation-and-setup",level:2},{value:"System Requirements",id:"system-requirements",level:3},{value:"Installation Process",id:"installation-process",level:3},{value:"Isaac Sim Architecture",id:"isaac-sim-architecture",level:2},{value:"Core Components",id:"core-components",level:3},{value:"1. USD (Universal Scene Description)",id:"1-usd-universal-scene-description",level:4},{value:"2. PhysX Physics Engine",id:"2-physx-physics-engine",level:4},{value:"3. RTX Renderer",id:"3-rtx-renderer",level:4},{value:"Programming Interface",id:"programming-interface",level:3},{value:"1. Isaac Sim Python API",id:"1-isaac-sim-python-api",level:4},{value:"2. Omniverse Kit Extensions",id:"2-omniverse-kit-extensions",level:4},{value:"Creating Humanoid Robot Models",id:"creating-humanoid-robot-models",level:2},{value:"1. Importing URDF Models",id:"1-importing-urdf-models",level:3},{value:"2. Robot Configuration",id:"2-robot-configuration",level:3},{value:"Environment Creation",id:"environment-creation",level:2},{value:"1. Basic Environments",id:"1-basic-environments",level:3},{value:"2. Complex Environments",id:"2-complex-environments",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:2},{value:"1. Camera Simulation",id:"1-camera-simulation",level:3},{value:"2. IMU Simulation",id:"2-imu-simulation",level:3},{value:"3. Force/Torque Sensors",id:"3-forcetorque-sensors",level:3},{value:"Physics Configuration for Humanoid Robots",id:"physics-configuration-for-humanoid-robots",level:2},{value:"1. Joint Configuration",id:"1-joint-configuration",level:3},{value:"2. Material Properties",id:"2-material-properties",level:3},{value:"Control Integration",id:"control-integration",level:2},{value:"1. ROS Bridge",id:"1-ros-bridge",level:3},{value:"2. Direct Control Interface",id:"2-direct-control-interface",level:3},{value:"Advanced Simulation Features",id:"advanced-simulation-features",level:2},{value:"1. Domain Randomization",id:"1-domain-randomization",level:3},{value:"2. Multi-Environment Training",id:"2-multi-environment-training",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"1. Simulation Parameters",id:"1-simulation-parameters",level:3},{value:"2. Graphics Optimization",id:"2-graphics-optimization",level:3},{value:"Debugging and Visualization",id:"debugging-and-visualization",level:2},{value:"1. Physics Debugging",id:"1-physics-debugging",level:3},{value:"2. Sensor Debugging",id:"2-sensor-debugging",level:3}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"isaac-sim-for-humanoid-robotics",children:"Isaac Sim for Humanoid Robotics"})}),"\n",(0,o.jsx)(i.p,{children:"Isaac Sim is NVIDIA's high-fidelity simulation environment built on the Omniverse platform, specifically designed for robotics applications. It provides photorealistic rendering, accurate physics simulation, and seamless integration with the ROS/ROS 2 ecosystem, making it ideal for developing complex humanoid robots."}),"\n",(0,o.jsx)(i.h2,{id:"overview-of-isaac-sim",children:"Overview of Isaac Sim"}),"\n",(0,o.jsx)(i.p,{children:"Isaac Sim is built on NVIDIA Omniverse, a real-time simulation and collaboration platform. It provides:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Photorealistic rendering"})," for accurate sensor simulation"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"High-fidelity physics"})," using PhysX engine"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Large-scale environments"})," with complex geometries"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Multi-robot simulation"})," capabilities"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"ROS/ROS 2 integration"})," for seamless workflow"]}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:"For humanoid robots, Isaac Sim offers unique advantages in simulating complex interactions between robots and their environments, which is critical for developing stable locomotion and manipulation behaviors."}),"\n",(0,o.jsx)(i.h2,{id:"installation-and-setup",children:"Installation and Setup"}),"\n",(0,o.jsx)(i.h3,{id:"system-requirements",children:"System Requirements"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Ubuntu 20.04 or 22.04 LTS"}),"\n",(0,o.jsx)(i.li,{children:"NVIDIA GPU with CUDA support (RTX 3070 or higher recommended)"}),"\n",(0,o.jsx)(i.li,{children:"16GB+ system RAM"}),"\n",(0,o.jsx)(i.li,{children:"100GB+ free disk space"}),"\n",(0,o.jsx)(i.li,{children:"Compatible graphics driver (470+)"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"installation-process",children:"Installation Process"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.strong,{children:"Install NVIDIA Container Toolkit:"})}),"\n"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"# Add NVIDIA package repositories\r\ncurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -\r\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID)\r\ncurl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\\r\n  sudo tee /etc/apt/sources.list.d/nvidia-docker.list\r\n\r\n# Install nvidia-container-toolkit\r\nsudo apt-get update\r\nsudo apt-get install -y nvidia-container-toolkit\r\nsudo systemctl restart docker\n"})}),"\n",(0,o.jsxs)(i.ol,{start:"2",children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.strong,{children:"Pull Isaac Sim Docker Image:"})}),"\n"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"docker pull nvcr.io/nvidia/isaac-sim:4.0.0\n"})}),"\n",(0,o.jsxs)(i.ol,{start:"3",children:["\n",(0,o.jsx)(i.li,{children:(0,o.jsx)(i.strong,{children:"Run Isaac Sim:"})}),"\n"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:'xhost +local:docker\r\ndocker run --gpus all -it --rm --network=host \\\r\n  --env "DISPLAY" \\\r\n  --volume="/tmp/.X11-unix:/tmp/.X11-unix:rw" \\\r\n  --volume="/home/$USER/.Xauthority:/root/.Xauthority:rw" \\\r\n  --volume="/home/$USER/isaac-sim-cache:/isaac-sim-cache" \\\r\n  nvcr.io/nvidia/isaac-sim:4.0.0\n'})}),"\n",(0,o.jsx)(i.h2,{id:"isaac-sim-architecture",children:"Isaac Sim Architecture"}),"\n",(0,o.jsx)(i.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(i.h4,{id:"1-usd-universal-scene-description",children:"1. USD (Universal Scene Description)"}),"\n",(0,o.jsx)(i.p,{children:"Isaac Sim uses USD as its core scene representation:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Hierarchical scene description"}),"\n",(0,o.jsx)(i.li,{children:"Multi-asset composition"}),"\n",(0,o.jsx)(i.li,{children:"Layering and referencing"}),"\n",(0,o.jsx)(i.li,{children:"Animation and simulation data"}),"\n"]}),"\n",(0,o.jsx)(i.h4,{id:"2-physx-physics-engine",children:"2. PhysX Physics Engine"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Accurate multi-body dynamics"}),"\n",(0,o.jsx)(i.li,{children:"Complex contact simulation"}),"\n",(0,o.jsx)(i.li,{children:"Realistic material properties"}),"\n",(0,o.jsx)(i.li,{children:"Stable constraint solving"}),"\n"]}),"\n",(0,o.jsx)(i.h4,{id:"3-rtx-renderer",children:"3. RTX Renderer"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Physically-based rendering"}),"\n",(0,o.jsx)(i.li,{children:"Real-time ray tracing"}),"\n",(0,o.jsx)(i.li,{children:"Accurate lighting simulation"}),"\n",(0,o.jsx)(i.li,{children:"High-quality sensor simulation"}),"\n"]}),"\n",(0,o.jsx)(i.h3,{id:"programming-interface",children:"Programming Interface"}),"\n",(0,o.jsx)(i.p,{children:"Isaac Sim provides multiple interfaces for robot development:"}),"\n",(0,o.jsx)(i.h4,{id:"1-isaac-sim-python-api",children:"1. Isaac Sim Python API"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'import omni\r\nimport omni.kit.app as app\r\nfrom omni.isaac.core import World\r\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\n\r\n# Initialize Isaac Sim\r\nworld = World(stage_units_in_meters=1.0)\r\n\r\n# Add robot to simulation\r\nassets_root_path = get_assets_root_path()\r\nif assets_root_path is None:\r\n    carb.log_error("Could not use Isaac Sim Assets folder")\r\nelse:\r\n    asset_path = assets_root_path + "/Isaac/Robots/Franka/franka_alt_fingers.usd"\r\n    add_reference_to_stage(usd_path=asset_path, prim_path="/World/Robot")\r\n\r\n# Reset and step simulation\r\nworld.reset()\r\nfor i in range(100):\r\n    world.step(render=True)\n'})}),"\n",(0,o.jsx)(i.h4,{id:"2-omniverse-kit-extensions",children:"2. Omniverse Kit Extensions"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"Custom extensions for specific robot types"}),"\n",(0,o.jsx)(i.li,{children:"GUI tools for environment creation"}),"\n",(0,o.jsx)(i.li,{children:"Scripted workflows for automation"}),"\n",(0,o.jsx)(i.li,{children:"Integration with external tools"}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"creating-humanoid-robot-models",children:"Creating Humanoid Robot Models"}),"\n",(0,o.jsx)(i.h3,{id:"1-importing-urdf-models",children:"1. Importing URDF Models"}),"\n",(0,o.jsx)(i.p,{children:"Isaac Sim supports importing URDF models with the URDF Importer extension:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'import omni\r\nfrom omni.isaac.core.utils.extensions import enable_extension\r\nfrom omni.importer.urdf import _urdf\r\n\r\n# Enable URDF extension\r\nenable_extension("omni.importer.urdf")\r\n\r\n# Import URDF\r\nurdf_interface = _urdf.acquire_urdf_interface()\r\nimport_config = _urdf.ImportConfig()\r\nimport_config.merge_fixed_joints = False\r\nimport_config.convex_decomposition = False\r\nimport_config.import_inertia_tensor = True\r\nimport_config.fix_base = True\r\nimport_config.make_default_prim = True\r\n\r\nurdf_interface.import_file(\r\n    file_path="path/to/humanoid.urdf",\r\n    import_config=import_config\r\n)\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-robot-configuration",children:"2. Robot Configuration"}),"\n",(0,o.jsx)(i.p,{children:"Properly configure humanoid robots for simulation:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.robots import Robot\r\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\r\nfrom omni.isaac.core.articulations import ArticulationView\r\n\r\n# Add humanoid robot to stage\r\nadd_reference_to_stage(\r\n    usd_path="path/to/humanoid.usd",\r\n    prim_path="/World/Humanoid"\r\n)\r\n\r\n# Create robot view for control\r\nhumanoid = world.scene.add(\r\n    Robot(\r\n        prim_path="/World/Humanoid",\r\n        name="humanoid_robot",\r\n        position=[0, 0, 1.0],\r\n        orientation=[0, 0, 0, 1]\r\n    )\r\n)\r\n\r\n# Create articulation view for joint control\r\nhumanoid_articulation = ArticulationView(\r\n    prim_path="/World/Humanoid",\r\n    name="humanoid_view",\r\n    reset_xform_properties=False\r\n)\r\nworld.scene.add(humanoid_articulation)\n'})}),"\n",(0,o.jsx)(i.h2,{id:"environment-creation",children:"Environment Creation"}),"\n",(0,o.jsx)(i.h3,{id:"1-basic-environments",children:"1. Basic Environments"}),"\n",(0,o.jsx)(i.p,{children:"Create simple environments for testing:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.objects import DynamicCuboid, VisualCuboid\r\nfrom omni.isaac.core.prims import XFormPrimView\r\nfrom omni.isaac.core.utils.prims import create_primitive\r\n\r\n# Create ground plane\r\ncreate_primitive(\r\n    prim_path="/World/GroundPlane",\r\n    primitive_props={\r\n        "prim_type": "Plane",\r\n        "size": 100,\r\n        "position": [0, 0, 0],\r\n        "orientation": [0, 0, 0, 1],\r\n        "color": [0.2, 0.2, 0.2]\r\n    }\r\n)\r\n\r\n# Add obstacles\r\nfor i in range(5):\r\n    obstacle = world.scene.add(\r\n        DynamicCuboid(\r\n            prim_path=f"/World/Obstacle{i}",\r\n            name=f"obstacle_{i}",\r\n            position=[i*2, 0, 0.5],\r\n            size=0.5,\r\n            mass=1.0,\r\n            color=[0.8, 0.1, 0.1]\r\n        )\r\n    )\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-complex-environments",children:"2. Complex Environments"}),"\n",(0,o.jsx)(i.p,{children:"For advanced humanoid testing:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.utils.stage import get_stage_units\r\nfrom pxr import UsdGeom, Gf\r\n\r\n# Create stairs\r\ndef create_stairs(prim_path, position, num_steps=5, step_size=[0.3, 1.0, 0.15]):\r\n    for i in range(num_steps):\r\n        step_position = [\r\n            position[0],\r\n            position[1],\r\n            position[2] + i * step_size[2] * 2\r\n        ]\r\n        \r\n        create_primitive(\r\n            prim_path=f"{prim_path}/Step{i}",\r\n            primitive_props={\r\n                "prim_type": "Box",\r\n                "position": step_position,\r\n                "size": step_size,\r\n                "color": [0.5, 0.5, 0.5]\r\n            }\r\n        )\r\n\r\n# Create stairs for humanoid testing\r\ncreate_stairs("/World/Stairs", [5, 0, 0.1])\n'})}),"\n",(0,o.jsx)(i.h2,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,o.jsx)(i.h3,{id:"1-camera-simulation",children:"1. Camera Simulation"}),"\n",(0,o.jsx)(i.p,{children:"Simulate RGB and depth cameras for perception:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.sensor import Camera\r\nimport numpy as np\r\n\r\n# Create camera\r\ncamera = Camera(\r\n    prim_path="/World/Humanoid/base_link/head_camera",\r\n    frequency=30,\r\n    resolution=(640, 480)\r\n)\r\n\r\n# Add camera to world\r\nworld.scene.add(camera)\r\n\r\n# Get camera data\r\nrgb_image = camera.get_rgb()\r\ndepth_image = camera.get_depth()\r\n\r\n# Process images\r\nrgb_array = np.array(rgb_image)\r\ndepth_array = np.array(depth_image)\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-imu-simulation",children:"2. IMU Simulation"}),"\n",(0,o.jsx)(i.p,{children:"For balance and orientation sensing:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.sensors import Imu\r\nfrom omni.isaac.core.utils.prims import get_prim_at_path\r\n\r\n# Create IMU sensor\r\nimu_sensor = Imu(\r\n    prim_path="/World/Humanoid/base_link/imu",\r\n    frequency=100\r\n)\r\n\r\n# Add to scene\r\nworld.scene.add(imu_sensor)\r\n\r\n# Get IMU data\r\nlinear_acceleration = imu_sensor.get_linear_acceleration()\r\nangular_velocity = imu_sensor.get_angular_velocity()\r\norientation = imu_sensor.get_orientation()\n'})}),"\n",(0,o.jsx)(i.h3,{id:"3-forcetorque-sensors",children:"3. Force/Torque Sensors"}),"\n",(0,o.jsx)(i.p,{children:"For contact detection and manipulation:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.sensors import ContactSensor\r\nfrom omni.isaac.core.utils.prims import get_prim_at_path\r\n\r\n# Create contact sensor for feet\r\nleft_foot_contact = ContactSensor(\r\n    prim_path="/World/Humanoid/left_foot/force_torque",\r\n    translation=np.array([0.0, 0.0, -0.05]),\r\n    orientation=np.array([1.0, 0.0, 0.0, 0.0]),\r\n    sensor_period=1.0/200.0,\r\n    min_threshold=0,\r\n    max_threshold=10000000,\r\n    radius=0.1\r\n)\r\n\r\nworld.scene.add(left_foot_contact)\r\n\r\n# Get contact information\r\ncontact_report = left_foot_contact.get_contact_force()\r\nis_contact = left_foot_contact.is_sensing()\n'})}),"\n",(0,o.jsx)(i.h2,{id:"physics-configuration-for-humanoid-robots",children:"Physics Configuration for Humanoid Robots"}),"\n",(0,o.jsx)(i.h3,{id:"1-joint-configuration",children:"1. Joint Configuration"}),"\n",(0,o.jsx)(i.p,{children:"Properly configure joints for realistic humanoid movement:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.utils.prims import get_prim_at_path\r\nfrom pxr import PhysxSchema\r\n\r\n# Configure joint properties\r\ndef configure_joint_dynamics(prim_path, damping=0.1, stiffness=0.0, max_velocity=10.0):\r\n    joint_prim = get_prim_at_path(prim_path)\r\n    \r\n    # Set joint dynamics\r\n    joint_prim.GetAttribute("physxJoints:jointDamping").Set(damping)\r\n    joint_prim.GetAttribute("physxJoints:jointStiffness").Set(stiffness)\r\n    joint_prim.GetAttribute("drive:angular:velocity:scale").Set(max_velocity)\r\n\r\n# Apply to humanoid joints\r\nconfigure_joint_dynamics("/World/Humanoid/left_knee_joint", damping=0.5, max_velocity=5.0)\r\nconfigure_joint_dynamics("/World/Humanoid/right_knee_joint", damping=0.5, max_velocity=5.0)\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-material-properties",children:"2. Material Properties"}),"\n",(0,o.jsx)(i.p,{children:"Set appropriate material properties for realistic interactions:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'from omni.isaac.core.materials import PhysicsMaterial\r\nfrom omni.isaac.core.utils.materials import add_material_to_stage\r\n\r\n# Create physics material for feet\r\nfoot_material = PhysicsMaterial(\r\n    prim_path="/World/Looks/foot_material",\r\n    static_friction=0.8,\r\n    dynamic_friction=0.8,\r\n    restitution=0.1  # Low restitution for stable contact\r\n)\r\n\r\n# Apply to foot geometry\r\nadd_material_to_stage(\r\n    prim_path="/World/Humanoid/left_foot_collision",\r\n    material_path=foot_material.prim_path\r\n)\n'})}),"\n",(0,o.jsx)(i.h2,{id:"control-integration",children:"Control Integration"}),"\n",(0,o.jsx)(i.h3,{id:"1-ros-bridge",children:"1. ROS Bridge"}),"\n",(0,o.jsx)(i.p,{children:"Connect Isaac Sim to ROS/ROS 2:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Enable ROS bridge extension\r\nfrom omni.isaac.core.utils.extensions import enable_extension\r\nenable_extension("omni.isaac.ros_bridge")\r\n\r\n# The ROS bridge will automatically publish sensor data\r\n# and subscribe to control commands\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-direct-control-interface",children:"2. Direct Control Interface"}),"\n",(0,o.jsx)(i.p,{children:"Control humanoid robots directly in Isaac Sim:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"import numpy as np\r\n\r\n# Get joint positions and velocities\r\njoint_positions = humanoid_articulation.get_joint_positions()\r\njoint_velocities = humanoid_articulation.get_joint_velocities()\r\n\r\n# Set joint positions (position control)\r\ntarget_positions = np.array([0.0, 0.5, -1.0, 0.0, 0.5, -1.0])  # Example: bent knees\r\nhumanoid_articulation.set_joint_position_targets(positions=target_positions)\r\n\r\n# Set joint efforts (effort control)\r\ntarget_efforts = np.array([10.0, 10.0, 10.0, 10.0, 10.0, 10.0])\r\nhumanoid_articulation.set_joint_efforts(efforts=target_efforts)\n"})}),"\n",(0,o.jsx)(i.h2,{id:"advanced-simulation-features",children:"Advanced Simulation Features"}),"\n",(0,o.jsx)(i.h3,{id:"1-domain-randomization",children:"1. Domain Randomization"}),"\n",(0,o.jsx)(i.p,{children:"For robust policy development:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'import random\r\n\r\nclass DomainRandomizer:\r\n    def __init__(self, world):\r\n        self.world = world\r\n        \r\n    def randomize_environment(self):\r\n        # Randomize lighting\r\n        light_prim = get_prim_at_path("/World/Light")\r\n        light_prim.GetAttribute("inputs:intensity").Set(random.uniform(500, 1500))\r\n        light_prim.GetAttribute("inputs:color").Set(\r\n            Gf.Vec3f(random.random(), random.random(), random.random())\r\n        )\r\n        \r\n        # Randomize material properties\r\n        for i in range(5):\r\n            obstacle_prim = get_prim_at_path(f"/World/Obstacle{i}")\r\n            friction = random.uniform(0.1, 1.0)\r\n            # Apply random friction to obstacle\r\n            \r\n    def randomize_robot_properties(self):\r\n        # Randomize robot mass, friction, etc.\r\n        pass\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-multi-environment-training",children:"2. Multi-Environment Training"}),"\n",(0,o.jsx)(i.p,{children:"For diverse training scenarios:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'class MultiEnvironmentTrainer:\r\n    def __init__(self, world):\r\n        self.world = world\r\n        self.environments = []\r\n        \r\n    def create_environments(self):\r\n        # Create multiple environments with different properties\r\n        for i in range(10):\r\n            env_transform = XFormPrim(f"/World/Env{i}", position=[i*10, 0, 0])\r\n            self.environments.append(env_transform)\r\n            \r\n    def reset_environment(self, env_idx):\r\n        # Reset specific environment\r\n        pass\n'})}),"\n",(0,o.jsx)(i.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(i.h3,{id:"1-simulation-parameters",children:"1. Simulation Parameters"}),"\n",(0,o.jsx)(i.p,{children:"Optimize for humanoid robot simulation:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"# Physics settings\r\nphysics_dt = 1.0 / 400.0  # 400Hz physics update\r\nrendering_interval = 2     # Render every 2 physics steps for 200Hz rendering\r\n\r\n# World settings\r\nworld.set_physics_dt(physics_dt, fixed_substeps=1)\r\nworld.set_rendering_dt(rendering_interval * physics_dt)\n"})}),"\n",(0,o.jsx)(i.h3,{id:"2-graphics-optimization",children:"2. Graphics Optimization"}),"\n",(0,o.jsx)(i.p,{children:"Balance visual quality with performance:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Reduce rendering quality during training\r\nomni.kit.commands.execute(\r\n    "ChangeSetting",\r\n    path="rtx-defaults/post/aa/active",\r\n    value=False  # Disable antialiasing\r\n)\r\n\r\nomni.kit.commands.execute(\r\n    "ChangeSetting", \r\n    path="rtx-defaults/pathtracing/active",\r\n    value=False  # Use rasterization instead of path tracing\r\n)\n'})}),"\n",(0,o.jsx)(i.h2,{id:"debugging-and-visualization",children:"Debugging and Visualization"}),"\n",(0,o.jsx)(i.h3,{id:"1-physics-debugging",children:"1. Physics Debugging"}),"\n",(0,o.jsx)(i.p,{children:"Visualize physics properties:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:'# Enable physics visualization\r\nomni.kit.commands.execute(\r\n    "ChangeSetting",\r\n    path="physics:drawColliders",\r\n    value=True\r\n)\r\n\r\nomni.kit.commands.execute(\r\n    "ChangeSetting",\r\n    path="physics:drawJoints",\r\n    value=True\r\n)\r\n\r\nomni.kit.commands.execute(\r\n    "ChangeSetting",\r\n    path="physics:drawCOM",\r\n    value=True\r\n)\n'})}),"\n",(0,o.jsx)(i.h3,{id:"2-sensor-debugging",children:"2. Sensor Debugging"}),"\n",(0,o.jsx)(i.p,{children:"Visualize sensor data:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-python",children:"# Enable camera visualization\r\ncamera.set_focal_length(24.0)\r\ncamera.set_resolution((640, 480))\r\ncamera.initialize()\r\n\r\n# Visualize point clouds from depth data\r\ndef visualize_depth_as_points(depth_data, camera_intrinsics):\r\n    # Convert depth to point cloud\r\n    points = depth_to_point_cloud(depth_data, camera_intrinsics)\r\n    # Visualize points in Isaac Sim\r\n    pass\n"})}),"\n",(0,o.jsx)(i.p,{children:"Isaac Sim provides a powerful platform for developing humanoid robots, combining high-fidelity simulation with realistic sensor modeling and physics. Its integration with the ROS ecosystem and support for reinforcement learning makes it an ideal tool for creating sophisticated humanoid behaviors that can transfer to real hardware."})]})}function m(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,o.jsx)(i,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453(n,i,e){e.d(i,{R:()=>a,x:()=>s});var r=e(6540);const o={},t=r.createContext(o);function a(n){const i=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),r.createElement(t.Provider,{value:i},n.children)}}}]);