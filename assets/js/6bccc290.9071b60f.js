"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[2761],{3636:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3-isaac/nav2-path-planning","title":"5. Autonomous Navigation with Nav2","description":"We have given our robot the ability to \\"see\\" and \\"locate\\" itself in a map. The next logical step is to give it the ability to move from point A to point B on its own. This is the domain of navigation, and in ROS 2, the industry-standard solution is the Navigation2 stack, or Nav2.","source":"@site/docs/module-3-isaac/5-nav2-path-planning.md","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/nav2-path-planning","permalink":"/physical-ai-book/docs/module-3-isaac/nav2-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-book/physical-ai-book/tree/main/docs/module-3-isaac/5-nav2-path-planning.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"5. Autonomous Navigation with Nav2","sidebar_label":"Nav2 Path Planning","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"VSLAM and Depth","permalink":"/physical-ai-book/docs/module-3-isaac/vslam-and-depth"},"next":{"title":"AI-Controlled Humanoid Brain","permalink":"/physical-ai-book/docs/module-3-isaac/ai-controlled-humanoid-brain"}}');var a=o(4848),i=o(8453);const s={title:"5. Autonomous Navigation with Nav2",sidebar_label:"Nav2 Path Planning",sidebar_position:5},l="5. Autonomous Navigation with Nav2",r={},c=[{value:"What is Nav2?",id:"what-is-nav2",level:2},{value:"Key Components of Nav2",id:"key-components-of-nav2",level:3},{value:"Integrating Isaac ROS with Nav2",id:"integrating-isaac-ros-with-nav2",level:2},{value:"Bipedal vs. Wheeled Navigation",id:"bipedal-vs-wheeled-navigation",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"5-autonomous-navigation-with-nav2",children:"5. Autonomous Navigation with Nav2"})}),"\n",(0,a.jsxs)(n.p,{children:['We have given our robot the ability to "see" and "locate" itself in a map. The next logical step is to give it the ability to move from point A to point B on its own. This is the domain of ',(0,a.jsx)(n.strong,{children:"navigation"}),", and in ROS 2, the industry-standard solution is the ",(0,a.jsx)(n.strong,{children:"Navigation2"})," stack, or ",(0,a.jsx)(n.strong,{children:"Nav2"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"what-is-nav2",children:"What is Nav2?"}),"\n",(0,a.jsx)(n.p,{children:"Nav2 is a powerful, highly configurable, and production-ready software stack for autonomous robot navigation. It takes sensor data, a map, and a goal pose as inputs, and it outputs velocity commands to move the robot to the goal while avoiding obstacles."}),"\n",(0,a.jsx)(n.p,{children:"Nav2 is not a single node, but a complex system of interacting servers, each responsible for a piece of the navigation puzzle."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:'graph TD\n    subgraph User / AI Agent\n        A[Goal Pose (e.g., from RViz or code)]\n    end\n    subgraph Nav2 Stack\n        B(Navigator)\n        C(Global Planner)\n        D(Local Planner / Controller)\n        E(Costmaps)\n    end\n    subgraph Robot Hardware / Simulation\n        F(Robot Base)\n    end\n\n    A -- "Navigate to this pose!" --\x3e B;\n    B -- "Plan a path from A to B" --\x3e C;\n    C -- Global Path --\x3e D;\n    E -- Obstacle Data --\x3e C;\n    E -- Obstacle Data --\x3e D;\n    D -- "/cmd_vel" --\x3e F;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"key-components-of-nav2",children:"Key Components of Nav2"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Costmaps (",(0,a.jsx)(n.code,{children:"costmap_2d"}),")"]}),": This is the foundation of Nav2's planning. Nav2 maintains two costmaps:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Global Costmap"}),": A 2D grid that represents the entire known environment. It's built from the static map provided by SLAM and is used by the global planner."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Local Costmap"}),": A smaller, rolling window around the robot that is constantly updated with real-time sensor data (like the ",(0,a.jsx)(n.code,{children:"/scan"}),' topic from our depth camera). It represents the immediate surroundings and is used by the local planner to avoid dynamic obstacles.\nIn both costmaps, each cell has a value representing how "costly" it is to travel through it. Cells with obstacles have a very high cost.']}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Global Planner (",(0,a.jsx)(n.code,{children:"nav2_planner"}),")"]}),": When you send a goal to Nav2, the global planner is responsible for finding the optimal path from the robot's current location to the goal on the global costmap. It uses algorithms like A* or Dijkstra to find the shortest path while avoiding known, static obstacles."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsxs)(n.strong,{children:["Local Planner / Controller (",(0,a.jsx)(n.code,{children:"nav2_controller"}),")"]}),": The local planner (also called the controller) is responsible for actually executing the global plan. It looks at the global path, the local costmap, and the robot's current state, and it computes a valid velocity command (",(0,a.jsx)(n.code,{children:"/cmd_vel"}),") to send to the robot's base. Its job is to follow the global path while avoiding any immediate obstacles (like a person walking in front of the robot) that weren't in the original map."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Navigator"}),": The top-level action server that coordinates the whole process. When it receives a ",(0,a.jsx)(n.code,{children:"NavigateToPose"})," action goal, it orchestrates calls to the planner and controller until the goal is reached, fails, or is cancelled."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"integrating-isaac-ros-with-nav2",children:"Integrating Isaac ROS with Nav2"}),"\n",(0,a.jsx)(n.p,{children:"Nav2 is the perfect consumer for the data generated by our Isaac ROS perception pipeline."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Input for Localization"}),": The VSLAM system (",(0,a.jsx)(n.code,{children:"isaac_ros_visual_slam"}),") provides the essential ",(0,a.jsx)(n.code,{children:"/tf"})," transform from the map frame to the odometry frame, constantly telling Nav2 where the robot is."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Input for Obstacle Avoidance"}),": The depth camera processing pipeline (",(0,a.jsx)(n.code,{children:"isaac_ros_depth_image_proc"}),") provides the ",(0,a.jsx)(n.code,{children:"/scan"})," topic, which the local costmap uses to detect and avoid immediate obstacles."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"By feeding the high-quality, low-latency data from our GPU-accelerated GEMs into Nav2, we can achieve very robust and performant navigation."}),"\n",(0,a.jsx)(n.h2,{id:"bipedal-vs-wheeled-navigation",children:"Bipedal vs. Wheeled Navigation"}),"\n",(0,a.jsxs)(n.p,{children:["A critical point for our humanoid robot is that Nav2 was originally designed for ",(0,a.jsx)(n.strong,{children:"wheeled robots"}),". It operates on a 2.5D costmap and outputs ",(0,a.jsx)(n.code,{children:"Twist"})," messages (linear x/y velocity and angular z velocity), which are perfect for a differential-drive robot."]}),"\n",(0,a.jsx)(n.p,{children:"This presents a challenge for a bipedal humanoid. A humanoid cannot simply spin in place or move sideways. Its motion is constrained by the dynamics of walking."}),"\n",(0,a.jsx)(n.p,{children:'To solve this, we need an intermediate "locomotion controller" node. This node\'s job is to:'}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Subscribe"})," to the ",(0,a.jsx)(n.code,{children:"/cmd_vel"})," topic from Nav2."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Translate"})," the desired linear and angular velocities into a stable walking gait. This might involve sending commands to a whole-body controller or a pattern generator that controls the legs."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Publish"})," the resulting joint trajectories to the robot's joint controllers."]}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-mermaid",children:"graph TD\n    A[Nav2 Controller] -- /cmd_vel (desired velocity) --\x3e B(Humanoid Locomotion Controller);\n    B -- Joint Trajectories --\x3e C(ros2_control / Joint Controllers);\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is a non-trivial problem and an active area of robotics research. For this textbook, we will often simplify the problem by starting with a wheeled base for our robot before moving on to the full complexity of bipedal locomotion."}),"\n",(0,a.jsx)(n.p,{children:"In the next chapter, we'll put all the pieces of our AI brain together, connecting perception, planning, and control into a single, cohesive system."})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>l});var t=o(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);