"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[671],{8453(e,r,n){n.d(r,{R:()=>i,x:()=>s});var a=n(6540);const o={},t=a.createContext(o);function i(e){const r=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(t.Provider,{value:r},e.children)}},8566(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>_});const a=JSON.parse('{"id":"module3/nav2-planning","title":"Navigation 2 (Nav2) for Humanoid Robots","description":"Navigation 2 (Nav2) is the latest navigation stack for ROS 2, designed to provide robust, reliable, and efficient navigation for mobile robots. For humanoid robots, Nav2 provides the essential capabilities needed to navigate complex, human-centric environments safely and efficiently.","source":"@site/docs/module3/nav2-planning.md","sourceDirName":"module3","slug":"/module3/nav2-planning","permalink":"/docs/module3/nav2-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/SyedZohaibTech/physical-ai-book/edit/main/docs/module3/nav2-planning.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Navigation 2 (Nav2) for Humanoid Robots"},"sidebar":"tutorialSidebar","previous":{"title":"Visual SLAM for Humanoid Navigation","permalink":"/docs/module3/visual-slam"},"next":{"title":"Introduction to Vision-Language-Action Systems","permalink":"/docs/module4/introduction"}}');var o=n(4848),t=n(8453);const i={sidebar_position:5,title:"Navigation 2 (Nav2) for Humanoid Robots"},s="Navigation 2 (Nav2) for Humanoid Robots",l={},_=[{value:"Overview of Nav2",id:"overview-of-nav2",level:2},{value:"Nav2 Architecture",id:"nav2-architecture",level:2},{value:"1. Core Components",id:"1-core-components",level:3},{value:"2. Behavior Trees in Nav2",id:"2-behavior-trees-in-nav2",level:3},{value:"Nav2 Installation and Setup",id:"nav2-installation-and-setup",level:2},{value:"1. Installing Nav2",id:"1-installing-nav2",level:3},{value:"2. Basic Nav2 Launch",id:"2-basic-nav2-launch",level:3},{value:"Configuration for Humanoid Robots",id:"configuration-for-humanoid-robots",level:2},{value:"1. Nav2 Parameters for Humanoid Robots",id:"1-nav2-parameters-for-humanoid-robots",level:3},{value:"2. Humanoid-Specific Behavior Trees",id:"2-humanoid-specific-behavior-trees",level:3},{value:"Humanoid Navigation Controllers",id:"humanoid-navigation-controllers",level:2},{value:"1. Balance-Aware Path Following",id:"1-balance-aware-path-following",level:3},{value:"2. Footstep Planning for Humanoid Navigation",id:"2-footstep-planning-for-humanoid-navigation",level:3},{value:"Humanoid Navigation Recovery Behaviors",id:"humanoid-navigation-recovery-behaviors",level:2},{value:"1. Balance Recovery",id:"1-balance-recovery",level:3},{value:"Integration with Humanoid Control Systems",id:"integration-with-humanoid-control-systems",level:2},{value:"1. High-Level Navigation Interface",id:"1-high-level-navigation-interface",level:3},{value:"Performance Optimization for Humanoid Navigation",id:"performance-optimization-for-humanoid-navigation",level:2},{value:"1. Adaptive Costmap Resolution",id:"1-adaptive-costmap-resolution",level:3}];function c(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"navigation-2-nav2-for-humanoid-robots",children:"Navigation 2 (Nav2) for Humanoid Robots"})}),"\n",(0,o.jsx)(r.p,{children:"Navigation 2 (Nav2) is the latest navigation stack for ROS 2, designed to provide robust, reliable, and efficient navigation for mobile robots. For humanoid robots, Nav2 provides the essential capabilities needed to navigate complex, human-centric environments safely and efficiently."}),"\n",(0,o.jsx)(r.h2,{id:"overview-of-nav2",children:"Overview of Nav2"}),"\n",(0,o.jsx)(r.p,{children:"Nav2 is a complete re-architecture of the ROS navigation stack, built specifically for ROS 2. It provides:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Behavior Trees"}),": For complex navigation behaviors"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Plugin Architecture"}),": For customizable navigation components"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Improved Safety"}),": With better collision avoidance and recovery"]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsx)(r.strong,{children:"Enhanced Performance"}),": With modern C++ implementation"]}),"\n"]}),"\n",(0,o.jsx)(r.p,{children:"For humanoid robots, Nav2 offers specialized capabilities to handle the unique challenges of bipedal locomotion and human-scale environments."}),"\n",(0,o.jsx)(r.h2,{id:"nav2-architecture",children:"Nav2 Architecture"}),"\n",(0,o.jsx)(r.h3,{id:"1-core-components",children:"1. Core Components"}),"\n",(0,o.jsx)(r.p,{children:"Nav2 consists of several key components:"}),"\n",(0,o.jsx)(r.mermaid,{value:"graph TD\r\n    A[Navigation Server] --\x3e B{Action Interface}\r\n    B --\x3e C[Global Planner]\r\n    B --\x3e D[Local Planner]\r\n    B --\x3e E[Controller]\r\n    B --\x3e F[Recovery Manager]\r\n    \r\n    C --\x3e G[Costmap 2D - Global]\r\n    D --\x3e H[Costmap 2D - Local]\r\n    E --\x3e I[Robot Controller]\r\n    \r\n    J[Sensor Data] --\x3e G\r\n    J --\x3e H\r\n    K[Map Data] --\x3e G\r\n    K --\x3e H"}),"\n",(0,o.jsx)(r.h3,{id:"2-behavior-trees-in-nav2",children:"2. Behavior Trees in Nav2"}),"\n",(0,o.jsx)(r.p,{children:"Behavior trees allow complex navigation behaviors to be composed from simpler actions:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'<root main_tree_to_execute="MainTree">\r\n    <BehaviorTree ID="MainTree">\r\n        <Sequence name="NavigateWithRecovery">\r\n            <PipelineSequence name="global_plan">\r\n                <RecoveryNode number_of_retries="6">\r\n                    <ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/>\r\n                    <ClearEntirely name="Clear Global Costmap" service_name="global_costmap/clear_entirely"/>\r\n                </RecoveryNode>\r\n            </PipelineSequence>\r\n            \r\n            <PipelineSequence name="local_plan">\r\n                <RecoveryNode number_of_retries="6">\r\n                    <FollowPath path="{path}" controller_id="FollowPath"/>\r\n                    <ClearEntirely name="Clear Local Costmap" service_name="local_costmap/clear_entirely"/>\r\n                </RecoveryNode>\r\n            </PipelineSequence>\r\n        </Sequence>\r\n    </BehaviorTree>\r\n</root>\n'})}),"\n",(0,o.jsx)(r.h2,{id:"nav2-installation-and-setup",children:"Nav2 Installation and Setup"}),"\n",(0,o.jsx)(r.h3,{id:"1-installing-nav2",children:"1. Installing Nav2"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-bash",children:"# Install Nav2 packages\r\nsudo apt update\r\nsudo apt install ros-humble-navigation2\r\nsudo apt install ros-humble-nav2-bringup\r\nsudo apt install ros-humble-nav2-gui-plugins\r\nsudo apt install ros-humble-nav2-rviz-plugins\n"})}),"\n",(0,o.jsx)(r.h3,{id:"2-basic-nav2-launch",children:"2. Basic Nav2 Launch"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"# launch/humanoid_nav2.launch.py\r\nimport os\r\nfrom launch import LaunchDescription\r\nfrom launch.actions import DeclareLaunchArgument, SetEnvironmentVariable\r\nfrom launch.substitutions import LaunchConfiguration\r\nfrom launch_ros.actions import Node\r\nfrom nav2_common.launch import RewrittenYaml\r\n\r\n\r\ndef generate_launch_description():\r\n    # Launch arguments\r\n    use_sim_time = LaunchConfiguration('use_sim_time')\r\n    autostart = LaunchConfiguration('autostart')\r\n    params_file = LaunchConfiguration('params_file')\r\n    \r\n    # Create launch description\r\n    ld = LaunchDescription()\r\n    \r\n    # Declare launch arguments\r\n    declare_use_sim_time = DeclareLaunchArgument(\r\n        'use_sim_time', \r\n        default_value='false',\r\n        description='Use simulation time if true'\r\n    )\r\n    \r\n    declare_autostart = DeclareLaunchArgument(\r\n        'autostart', \r\n        default_value='true',\r\n        description='Automatically start the nav2 stack'\r\n    )\r\n    \r\n    declare_params_file = DeclareLaunchArgument(\r\n        'params_file',\r\n        default_value=os.path.join(\r\n            get_package_share_directory('my_humanoid_package'),\r\n            'config',\r\n            'nav2_params.yaml'\r\n        ),\r\n        description='Full path to the ROS2 parameters file to use for all launched nodes'\r\n    )\r\n    \r\n    # Create the Nav2 node\r\n    nav2_node = Node(\r\n        package='nav2_bt_navigator',\r\n        executable='bt_navigator',\r\n        name='bt_navigator',\r\n        output='screen',\r\n        parameters=[params_file, {'use_sim_time': use_sim_time}]\r\n    )\r\n    \r\n    # Add actions to launch description\r\n    ld.add_action(declare_use_sim_time)\r\n    ld.add_action(declare_autostart)\r\n    ld.add_action(declare_params_file)\r\n    ld.add_action(nav2_node)\r\n    \r\n    return ld\n"})}),"\n",(0,o.jsx)(r.h2,{id:"configuration-for-humanoid-robots",children:"Configuration for Humanoid Robots"}),"\n",(0,o.jsx)(r.h3,{id:"1-nav2-parameters-for-humanoid-robots",children:"1. Nav2 Parameters for Humanoid Robots"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-yaml",children:'# config/nav2_params.yaml\r\namcl:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    alpha1: 0.2\r\n    alpha2: 0.2\r\n    alpha3: 0.2\r\n    alpha4: 0.2\r\n    alpha5: 0.2\r\n    base_frame_id: "base_footprint"\r\n    beam_skip_distance: 0.5\r\n    beam_skip_error_threshold: 0.9\r\n    beam_skip_threshold: 0.3\r\n    do_beamskip: false\r\n    global_frame_id: "map"\r\n    lambda_short: 0.1\r\n    laser_likelihood_max_dist: 2.0\r\n    laser_max_range: 100.0\r\n    laser_min_range: -1.0\r\n    laser_model_type: "likelihood_field"\r\n    max_beams: 60\r\n    max_particles: 2000\r\n    min_particles: 500\r\n    odom_frame_id: "odom"\r\n    pf_err: 0.05\r\n    pf_z: 0.99\r\n    recovery_alpha_fast: 0.0\r\n    recovery_alpha_slow: 0.0\r\n    resample_interval: 1\r\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\r\n    save_pose_rate: 0.5\r\n    sigma_hit: 0.2\r\n    tf_broadcast: true\r\n    transform_tolerance: 1.0\r\n    update_min_a: 0.2\r\n    update_min_d: 0.25\r\n    z_hit: 0.5\r\n    z_max: 0.05\r\n    z_rand: 0.5\r\n    z_short: 0.05\r\n\r\namcl_map_client:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\namcl_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\nbt_navigator:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    global_frame: map\r\n    robot_base_frame: base_footprint\r\n    odom_topic: /odom\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    enable_groot_monitoring: True\r\n    groot_zmq_publisher_port: 1666\r\n    groot_zmq_server_port: 1667\r\n    # Specify the path where the behavior tree file is located\r\n    default_nav_through_poses_bt_xml: "humanoid_navigate_through_poses_w_replanning_and_recovery.xml"\r\n    default_nav_to_pose_bt_xml: "humanoid_navigate_to_pose_w_replanning_and_recovery.xml"\r\n    plugin_lib_names:\r\n    - nav2_compute_path_to_pose_action_bt_node\r\n    - nav2_compute_path_through_poses_action_bt_node\r\n    - nav2_smooth_path_action_bt_node\r\n    - nav2_follow_path_action_bt_node\r\n    - nav2_spin_action_bt_node\r\n    - nav2_wait_action_bt_node\r\n    - nav2_assisted_teleop_action_bt_node\r\n    - nav2_back_up_action_bt_node\r\n    - nav2_drive_on_heading_bt_node\r\n    - nav2_clear_costmap_service_bt_node\r\n    - nav2_is_stuck_condition_bt_node\r\n    - nav2_have_feedback_condition_bt_node\r\n    - nav2_have_recovery_attempts_condition_bt_node\r\n    - nav2_external_condition\r\n    - nav2_recovery_node_bt_node\r\n    - nav2_pipeline_sequence_bt_node\r\n    - nav2_round_robin_node_bt_node\r\n    - nav2_transform_available_condition_bt_node\r\n    - nav2_time_expired_condition_bt_node\r\n    - nav2_distance_traveled_condition_bt_node\r\n    - nav2_single_trigger_bt_node\r\n    - nav2_is_battery_low_condition_bt_node\r\n    - nav2_navigate_through_poses_action_bt_node\r\n    - nav2_navigate_to_pose_action_bt_node\r\n    - nav2_remove_passed_goals_action_bt_node\r\n    - nav2_planner_selector_bt_node\r\n    - nav2_controller_selector_bt_node\r\n    - nav2_goal_checker_selector_bt_node\r\n    - nav2_controller_cancel_bt_node\r\n    - nav2_path_longer_on_approach_bt_node\r\n    - nav2_reinitialize_global_localization_service_bt_node\r\n    - nav2_rate_controller_bt_node\r\n    - nav2_distance_controller_bt_node\r\n    - nav2_speed_controller_bt_node\r\n    - nav2_truncate_path_action_bt_node\r\n    - nav2_truncate_path_local_action_bt_node\r\n    - nav2_goal_updater_node_bt_node\r\n    - nav2_recovery_triggerer_bt_node\r\n    - nav2_wait_cancel_bt_node\r\n    - nav2_spin_cancel_bt_node\r\n    - nav2_back_up_cancel_bt_node\r\n    - nav2_assisted_teleop_cancel_bt_node\r\n    - nav2_drive_on_heading_cancel_bt_node\r\n\r\nbt_navigator_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.001\r\n    # Humanoid-specific controllers\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugin: "goal_checker"\r\n    controller_plugins: ["FollowPath"]\r\n    \r\n    # Humanoid path follower\r\n    FollowPath:\r\n      plugin: "nav2_mppi_controller::MPPIController"\r\n      time_steps: 50\r\n      model_dt: 0.05\r\n      batch_size: 1000\r\n      vx_std: 0.2\r\n      vy_std: 0.2\r\n      wz_std: 0.3\r\n      vx_max: 0.5\r\n      vx_min: -0.2\r\n      vy_max: 0.3\r\n      vy_min: -0.3\r\n      wz_max: 0.5\r\n      wz_min: -0.5\r\n      xy_goal_tolerance: 0.25\r\n      yaw_goal_tolerance: 0.1\r\n      goal_checker: "simple_goal_checker"\r\n      path_publisher: "path_pub"\r\n      critic_names: [\r\n        "ConstraintCritic",\r\n        "GoalCritic",\r\n        "ObstacleCritic",\r\n        "PreferForwardCritic",\r\n        "TowardGoalCritic",\r\n        "TwirlingCritic"\r\n      ]\r\n      ConstraintCritic.scale: 1.0\r\n      GoalCritic.scale: 2.0\r\n      ObstacleCritic.scale: 2.0\r\n      ObstacleCritic.threshold_to_remember: 1.0\r\n      PreferForwardCritic.scale: 0.5\r\n      TowardGoalCritic.scale: 3.0\r\n      TowardGoalCritic.lookahead_resolution: 0.5\r\n      TowardGoalCritic.lookahead_time: 1.0\r\n      TwirlingCritic.scale: 1.0\r\n\r\ncontroller_server_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\n# Global Costmap Configuration for Humanoid Robots\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: map\r\n      robot_base_frame: base_footprint\r\n      use_sim_time: False\r\n      robot_radius: 0.3  # Humanoid robot radius\r\n      resolution: 0.05\r\n      track_unknown_space: true\r\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0  # Humanoid height consideration\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_subscribe_transient_local: True\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\r\n      always_send_full_costmap: True\r\n\r\nglobal_costmap_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\n# Local Costmap Configuration for Humanoid Robots\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 5.0\r\n      publish_frequency: 2.0\r\n      global_frame: odom\r\n      robot_base_frame: base_footprint\r\n      use_sim_time: False\r\n      robot_radius: 0.3  # Humanoid robot radius\r\n      resolution: 0.05\r\n      width: 6\r\n      height: 6\r\n      plugins: ["obstacle_layer", "voxel_layer", "inflation_layer"]\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n      voxel_layer:\r\n        plugin: "nav2_costmap_2d::VoxelLayer"\r\n        enabled: True\r\n        publish_voxel_map: True\r\n        origin_z: 0.0\r\n        z_resolution: 0.2\r\n        z_voxels: 10\r\n        max_obstacle_height: 2.0\r\n        mark_threshold: 0\r\n        observation_sources: pointcloud\r\n        pointcloud:\r\n          topic: /humanoid_depth/points\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "PointCloud2"\r\n          min_obstacle_height: 0.0\r\n          obstacle_range: 2.5\r\n          raytrace_range: 3.0\r\n          transform_tolerance: 0.2\r\n          observation_persistence: 0.0\r\n          expected_update_rate: 0.0\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.55\r\n      always_send_full_costmap: True\r\n\r\nlocal_costmap_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    use_sim_time: False\r\n    planner_plugins: ["GridBased"]\r\n    GridBased:\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: false\r\n      allow_unknown: true\r\n\r\nplanner_server_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: False\r\n\r\nrecoveries_server:\r\n  ros__parameters:\r\n    costmap_topic: local_costmap/costmap_raw\r\n    footprint_topic: local_costmap/published_footprint\r\n    cycle_frequency: 10.0\r\n    recovery_plugins: ["spin", "backup", "wait"]\r\n    spin:\r\n      plugin: "nav2_recoveries::Spin"\r\n      rotation_speed: 0.5  # Slower for humanoid stability\r\n      max_rotation_attempts: 17\r\n    backup:\r\n      plugin: "nav2_recoveries::BackUp"\r\n      backup_dist: -0.15  # Conservative for humanoid\r\n      backup_speed: 0.05\r\n    wait:\r\n      plugin: "nav2_recoveries::Wait"\r\n      wait_duration: 1.0\r\n\r\nrobot_state_publisher:\r\n  ros__parameters:\r\n    use_sim_time: False\n'})}),"\n",(0,o.jsx)(r.h3,{id:"2-humanoid-specific-behavior-trees",children:"2. Humanoid-Specific Behavior Trees"}),"\n",(0,o.jsx)(r.p,{children:"For humanoid robots, we need specialized behavior trees that consider bipedal locomotion:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-xml",children:'\x3c!-- humanoid_navigate_to_pose_w_replanning_and_recovery.xml --\x3e\r\n<root main_tree_to_execute="MainTree">\r\n    <BehaviorTree ID="MainTree">\r\n        <RecoveryNode number_of_retries="4" name="NavigateRecovery">\r\n            <PipelineSequence name="NavigateWithReplanning">\r\n                <RateController hz="1.0">\r\n                    <ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/>\r\n                </RateController>\r\n                <RecoveryNode number_of_retries="4" name="FollowPathRecovery">\r\n                    <FollowPath path="{path}" controller_id="FollowPath"/>\r\n                    <ReactiveFallback name="FollowPathWithRecoveryFallback">\r\n                        <GoalReached goal="{goal}"/>\r\n                        <ClearEntirely service_name="local_costmap/clear_entirely"/>\r\n                    </ReactiveFallback>\r\n                </RecoveryNode>\r\n            </PipelineSequence>\r\n            <ReactiveFallback name="RecoveryFallback">\r\n                <ClearEntirely service_name="local_costmap/clear_entirely"/>\r\n                <ClearEntirely service_name="global_costmap/clear_entirely"/>\r\n            </ReactiveFallback>\r\n        </RecoveryNode>\r\n    </BehaviorTree>\r\n</root>\n'})}),"\n",(0,o.jsx)(r.h2,{id:"humanoid-navigation-controllers",children:"Humanoid Navigation Controllers"}),"\n",(0,o.jsx)(r.h3,{id:"1-balance-aware-path-following",children:"1. Balance-Aware Path Following"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist, PoseStamped\r\nfrom nav_msgs.msg import Path\r\nfrom sensor_msgs.msg import Imu\r\nimport numpy as np\r\nfrom scipy.spatial.transform import Rotation as R\r\n\r\nclass BalanceAwareController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'balance_aware_controller\')\r\n        \r\n        # Subscriptions\r\n        self.imu_sub = self.create_subscription(\r\n            Imu, \'/imu/data\', self.imu_callback, 10\r\n        )\r\n        \r\n        self.path_sub = self.create_subscription(\r\n            Path, \'/plan\', self.path_callback, 10\r\n        )\r\n        \r\n        # Publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        \r\n        # Parameters\r\n        self.max_linear_vel = 0.3  # Conservative for balance\r\n        self.max_angular_vel = 0.3\r\n        self.balance_threshold = 0.2  # Radians\r\n        \r\n        # State\r\n        self.current_imu_orientation = np.array([0.0, 0.0, 0.0, 1.0])\r\n        self.current_path = None\r\n        self.path_index = 0\r\n        self.is_balanced = True\r\n        \r\n        # Timer for control loop\r\n        self.control_timer = self.create_timer(0.05, self.control_loop)\r\n    \r\n    def imu_callback(self, msg):\r\n        """Update robot orientation from IMU"""\r\n        self.current_imu_orientation = np.array([\r\n            msg.orientation.x,\r\n            msg.orientation.y,\r\n            msg.orientation.z,\r\n            msg.orientation.w\r\n        ])\r\n        \r\n        # Check if robot is balanced\r\n        self.is_balanced = self.check_balance()\r\n    \r\n    def check_balance(self):\r\n        """Check if robot is within balance limits"""\r\n        # Convert quaternion to Euler angles\r\n        r = R.from_quat(self.current_imu_orientation)\r\n        euler = r.as_euler(\'xyz\')\r\n        \r\n        # Check if roll or pitch exceeds threshold\r\n        return abs(euler[0]) < self.balance_threshold and abs(euler[1]) < self.balance_threshold\r\n    \r\n    def path_callback(self, msg):\r\n        """Update path to follow"""\r\n        self.current_path = msg.poses\r\n        self.path_index = 0\r\n    \r\n    def control_loop(self):\r\n        """Main control loop"""\r\n        if not self.current_path or not self.is_balanced:\r\n            # Stop if no path or not balanced\r\n            self.publish_stop_command()\r\n            return\r\n        \r\n        # Calculate control command\r\n        cmd_vel = self.calculate_control_command()\r\n        \r\n        # Publish command if balanced\r\n        if self.is_balanced:\r\n            self.cmd_vel_pub.publish(cmd_vel)\r\n        else:\r\n            # Stop if not balanced\r\n            self.publish_stop_command()\r\n    \r\n    def calculate_control_command(self):\r\n        """Calculate velocity command to follow path"""\r\n        if self.path_index >= len(self.current_path):\r\n            # Reached end of path\r\n            return self.create_twist(0.0, 0.0, 0.0)\r\n        \r\n        # Get current robot pose (simplified - in practice would use TF)\r\n        current_pose = self.get_current_pose()\r\n        \r\n        # Get target pose from path\r\n        target_pose = self.current_path[self.path_index].pose.position\r\n        current_pos = current_pose.position\r\n        \r\n        # Calculate distance to target\r\n        distance = np.sqrt(\r\n            (target_pose.x - current_pos.x)**2 + \r\n            (target_pose.y - current_pos.y)**2\r\n        )\r\n        \r\n        # Check if reached current target\r\n        if distance < 0.1:  # 10cm threshold\r\n            self.path_index += 1\r\n            if self.path_index >= len(self.current_path):\r\n                return self.create_twist(0.0, 0.0, 0.0)\r\n        \r\n        # Calculate desired direction\r\n        dx = target_pose.x - current_pos.x\r\n        dy = target_pose.y - current_pos.y\r\n        \r\n        # Calculate desired heading\r\n        desired_yaw = np.arctan2(dy, dx)\r\n        \r\n        # Get current heading (simplified)\r\n        current_yaw = self.get_current_yaw()\r\n        \r\n        # Calculate angular error\r\n        angle_error = desired_yaw - current_yaw\r\n        # Normalize angle to [-pi, pi]\r\n        angle_error = ((angle_error + np.pi) % (2 * np.pi)) - np.pi\r\n        \r\n        # Create twist command\r\n        cmd = Twist()\r\n        \r\n        # Set linear velocity proportional to distance but limited\r\n        cmd.linear.x = min(self.max_linear_vel, max(0.05, distance * 0.5))\r\n        \r\n        # Set angular velocity proportional to angle error but limited\r\n        cmd.angular.z = max(-self.max_angular_vel, min(self.max_angular_vel, angle_error * 1.0))\r\n        \r\n        return cmd\r\n    \r\n    def get_current_pose(self):\r\n        """Get current robot pose (simplified)"""\r\n        # In practice, this would use TF to get the robot\'s pose\r\n        from geometry_msgs.msg import Pose\r\n        return Pose()\r\n    \r\n    def get_current_yaw(self):\r\n        """Get current robot yaw from orientation"""\r\n        r = R.from_quat(self.current_imu_orientation)\r\n        euler = r.as_euler(\'xyz\')\r\n        return euler[2]  # Yaw is the z component\r\n    \r\n    def create_twist(self, linear_x, linear_y, angular_z):\r\n        """Create Twist message"""\r\n        twist = Twist()\r\n        twist.linear.x = linear_x\r\n        twist.linear.y = linear_y\r\n        twist.angular.z = angular_z\r\n        return twist\r\n    \r\n    def publish_stop_command(self):\r\n        """Publish zero velocity command"""\r\n        stop_cmd = self.create_twist(0.0, 0.0, 0.0)\r\n        self.cmd_vel_pub.publish(stop_cmd)\n'})}),"\n",(0,o.jsx)(r.h3,{id:"2-footstep-planning-for-humanoid-navigation",children:"2. Footstep Planning for Humanoid Navigation"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'import numpy as np\r\nfrom scipy.spatial.distance import euclidean\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Point\r\nfrom visualization_msgs.msg import Marker, MarkerArray\r\n\r\nclass FootstepPlanner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'footstep_planner\')\r\n        \r\n        # Publishers for visualization\r\n        self.footstep_viz_pub = self.create_publisher(MarkerArray, \'/footsteps_viz\', 10)\r\n        \r\n        # Parameters\r\n        self.step_width = 0.2  # Distance between feet\r\n        self.max_step_length = 0.3  # Maximum step length\r\n        self.step_height = 0.1  # Height of step arc\r\n        \r\n        # Robot state\r\n        self.left_foot_pos = np.array([0.0, self.step_width/2, 0.0])\r\n        self.right_foot_pos = np.array([0.0, -self.step_width/2, 0.0])\r\n        self.support_foot = "left"  # Which foot is supporting weight\r\n    \r\n    def plan_footsteps(self, path):\r\n        """Plan footstep sequence to follow path"""\r\n        footsteps = []\r\n        \r\n        # Start with current foot positions\r\n        footsteps.append(("left", self.left_foot_pos.copy()))\r\n        footsteps.append(("right", self.right_foot_pos.copy()))\r\n        \r\n        # Follow path with alternating footsteps\r\n        for i in range(1, len(path)):\r\n            target_pos = np.array([path[i].pose.position.x, path[i].pose.position.y, 0])\r\n            current_pos = np.array([path[i-1].pose.position.x, path[i-1].pose.position.y, 0])\r\n            \r\n            # Calculate direction of movement\r\n            direction = target_pos - current_pos\r\n            direction_norm = direction / np.linalg.norm(direction)\r\n            \r\n            # Determine which foot to move (opposite of current support foot)\r\n            if self.support_foot == "left":\r\n                moving_foot = "right"\r\n                current_foot_pos = self.right_foot_pos\r\n            else:\r\n                moving_foot = "left"\r\n                current_foot_pos = self.left_foot_pos\r\n            \r\n            # Calculate new foot position\r\n            step_length = min(self.max_step_length, np.linalg.norm(direction))\r\n            new_foot_pos = current_pos + direction_norm * step_length\r\n            \r\n            # Update foot position\r\n            if moving_foot == "left":\r\n                self.left_foot_pos = new_foot_pos\r\n            else:\r\n                self.right_foot_pos = new_foot_pos\r\n            \r\n            # Update support foot\r\n            self.support_foot = moving_foot\r\n            \r\n            # Add to footsteps\r\n            footsteps.append((moving_foot, new_foot_pos.copy()))\r\n        \r\n        return footsteps\r\n    \r\n    def visualize_footsteps(self, footsteps):\r\n        """Visualize footsteps in RViz"""\r\n        marker_array = MarkerArray()\r\n        \r\n        for i, (foot, pos) in enumerate(footsteps):\r\n            marker = Marker()\r\n            marker.header.frame_id = "map"\r\n            marker.header.stamp = self.get_clock().now().to_msg()\r\n            marker.ns = "footsteps"\r\n            marker.id = i\r\n            marker.type = Marker.CYLINDER\r\n            marker.action = Marker.ADD\r\n            \r\n            # Position\r\n            marker.pose.position.x = pos[0]\r\n            marker.pose.position.y = pos[1]\r\n            marker.pose.position.z = pos[2] + 0.01  # Slightly above ground\r\n            \r\n            # Orientation\r\n            marker.pose.orientation.w = 1.0\r\n            \r\n            # Scale\r\n            marker.scale.x = 0.1  # Diameter\r\n            marker.scale.y = 0.1\r\n            marker.scale.z = 0.02  # Height\r\n            \r\n            # Color\r\n            if foot == "left":\r\n                marker.color.r = 1.0\r\n                marker.color.g = 0.0\r\n                marker.color.b = 0.0\r\n            else:\r\n                marker.color.r = 0.0\r\n                marker.color.g = 0.0\r\n                marker.color.b = 1.0\r\n            marker.color.a = 1.0\r\n            \r\n            marker_array.markers.append(marker)\r\n        \r\n        self.footstep_viz_pub.publish(marker_array)\n'})}),"\n",(0,o.jsx)(r.h2,{id:"humanoid-navigation-recovery-behaviors",children:"Humanoid Navigation Recovery Behaviors"}),"\n",(0,o.jsx)(r.h3,{id:"1-balance-recovery",children:"1. Balance Recovery"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist\r\nfrom sensor_msgs.msg import Imu\r\nimport numpy as np\r\n\r\nclass BalanceRecovery(Node):\r\n    def __init__(self):\r\n        super().__init__(\'balance_recovery\')\r\n        \r\n        # Publishers and subscribers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.imu_sub = self.create_subscription(Imu, \'/imu/data\', self.imu_callback, 10)\r\n        \r\n        # Parameters\r\n        self.balance_threshold = 0.3  # Radians\r\n        self.recovery_angular_vel = 0.2\r\n        self.max_recovery_time = 5.0  # seconds\r\n        \r\n        # State\r\n        self.current_orientation = None\r\n        self.in_recovery = False\r\n        self.recovery_start_time = None\r\n        \r\n        # Timer for recovery checks\r\n        self.recovery_timer = self.create_timer(0.1, self.check_balance)\r\n    \r\n    def imu_callback(self, msg):\r\n        """Update orientation from IMU"""\r\n        self.current_orientation = np.array([\r\n            msg.orientation.x,\r\n            msg.orientation.y,\r\n            msg.orientation.z,\r\n            msg.orientation.w\r\n        ])\r\n    \r\n    def check_balance(self):\r\n        """Check if robot is out of balance and initiate recovery if needed"""\r\n        if self.current_orientation is None:\r\n            return\r\n        \r\n        # Convert quaternion to Euler angles\r\n        from scipy.spatial.transform import Rotation as R\r\n        r = R.from_quat(self.current_orientation)\r\n        euler = r.as_euler(\'xyz\')\r\n        \r\n        # Check if roll or pitch exceeds threshold\r\n        is_tilted = abs(euler[0]) > self.balance_threshold or abs(euler[1]) > self.balance_threshold\r\n        \r\n        if is_tilted and not self.in_recovery:\r\n            # Start recovery behavior\r\n            self.start_recovery(euler)\r\n        elif not is_tilted and self.in_recovery:\r\n            # Stop recovery if balanced\r\n            self.stop_recovery()\r\n        \r\n        if self.in_recovery:\r\n            # Continue recovery behavior\r\n            self.execute_recovery(euler)\r\n    \r\n    def start_recovery(self, euler):\r\n        """Start balance recovery behavior"""\r\n        self.in_recovery = True\r\n        self.recovery_start_time = self.get_clock().now().nanoseconds / 1e9\r\n        \r\n        # Log the recovery\r\n        self.get_logger().info(f"Balance recovery initiated. Current tilt: roll={euler[0]:.3f}, pitch={euler[1]:.3f}")\r\n    \r\n    def stop_recovery(self):\r\n        """Stop balance recovery behavior"""\r\n        self.in_recovery = False\r\n        self.recovery_start_time = None\r\n        \r\n        # Publish stop command\r\n        stop_cmd = Twist()\r\n        self.cmd_vel_pub.publish(stop_cmd)\r\n        \r\n        self.get_logger().info("Balance recovery completed")\r\n    \r\n    def execute_recovery(self, euler):\r\n        """Execute balance recovery movement"""\r\n        current_time = self.get_clock().now().nanoseconds / 1e9\r\n        \r\n        # Check if recovery has timed out\r\n        if current_time - self.recovery_start_time > self.max_recovery_time:\r\n            self.get_logger().warn("Balance recovery timed out")\r\n            self.stop_recovery()\r\n            return\r\n        \r\n        # Determine recovery movement based on tilt\r\n        cmd = Twist()\r\n        \r\n        # Counteract roll (side-to-side tilt)\r\n        if abs(euler[0]) > self.balance_threshold:\r\n            cmd.angular.y = -np.sign(euler[0]) * self.recovery_angular_vel\r\n        \r\n        # Counteract pitch (forward-backward tilt)\r\n        if abs(euler[1]) > self.balance_threshold:\r\n            cmd.angular.x = -np.sign(euler[1]) * self.recovery_angular_vel\r\n        \r\n        # Publish recovery command\r\n        self.cmd_vel_pub.publish(cmd)\n'})}),"\n",(0,o.jsx)(r.h2,{id:"integration-with-humanoid-control-systems",children:"Integration with Humanoid Control Systems"}),"\n",(0,o.jsx)(r.h3,{id:"1-high-level-navigation-interface",children:"1. High-Level Navigation Interface"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom rclpy.action import ActionClient\r\nfrom std_msgs.msg import String\r\n\r\nclass HumanoidNavigator(Node):\r\n    def __init__(self):\r\n        super().__init__(\'humanoid_navigator\')\r\n        \r\n        # Action client for Nav2\r\n        self.nav_to_pose_client = ActionClient(self, NavigateToPose, \'navigate_to_pose\')\r\n        \r\n        # Publisher for status\r\n        self.status_pub = self.create_publisher(String, \'/navigation_status\', 10)\r\n        \r\n        # Navigation state\r\n        self.is_navigating = False\r\n        self.current_goal = None\r\n    \r\n    def navigate_to_pose(self, x, y, theta):\r\n        """Navigate to a specific pose"""\r\n        # Wait for action server\r\n        if not self.nav_to_pose_client.wait_for_server(timeout_sec=5.0):\r\n            self.get_logger().error("Navigation action server not available")\r\n            return False\r\n        \r\n        # Create goal\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose.header.frame_id = \'map\'\r\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\r\n        goal_msg.pose.pose.position.x = x\r\n        goal_msg.pose.pose.position.y = y\r\n        goal_msg.pose.pose.position.z = 0.0\r\n        \r\n        # Convert theta to quaternion\r\n        from scipy.spatial.transform import Rotation as R\r\n        quat = R.from_euler(\'z\', theta).as_quat()\r\n        goal_msg.pose.pose.orientation.x = quat[0]\r\n        goal_msg.pose.pose.orientation.y = quat[1]\r\n        goal_msg.pose.pose.orientation.z = quat[2]\r\n        goal_msg.pose.pose.orientation.w = quat[3]\r\n        \r\n        # Send goal\r\n        self.current_goal = goal_msg\r\n        self.is_navigating = True\r\n        \r\n        future = self.nav_to_pose_client.send_goal_async(\r\n            goal_msg,\r\n            feedback_callback=self.feedback_callback\r\n        )\r\n        \r\n        future.add_done_callback(self.goal_response_callback)\r\n        \r\n        return True\r\n    \r\n    def goal_response_callback(self, future):\r\n        """Handle goal response"""\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info(\'Goal rejected\')\r\n            self.is_navigating = False\r\n            return\r\n        \r\n        self.get_logger().info(\'Goal accepted\')\r\n        \r\n        # Get result future\r\n        get_result_future = goal_handle.get_result_async()\r\n        get_result_future.add_done_callback(self.get_result_callback)\r\n    \r\n    def get_result_callback(self, future):\r\n        """Handle navigation result"""\r\n        result = future.result().result\r\n        self.get_logger().info(f\'Navigation result: {result}\')\r\n        self.is_navigating = False\r\n        \r\n        # Publish status\r\n        status_msg = String()\r\n        status_msg.data = "Navigation completed" if result.error_code == 0 else "Navigation failed"\r\n        self.status_pub.publish(status_msg)\r\n    \r\n    def feedback_callback(self, feedback_msg):\r\n        """Handle navigation feedback"""\r\n        feedback = feedback_msg.feedback\r\n        self.get_logger().info(f\'Navigation feedback: {feedback.current_pose}\')\n'})}),"\n",(0,o.jsx)(r.h2,{id:"performance-optimization-for-humanoid-navigation",children:"Performance Optimization for Humanoid Navigation"}),"\n",(0,o.jsx)(r.h3,{id:"1-adaptive-costmap-resolution",children:"1. Adaptive Costmap Resolution"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:'class AdaptiveCostmap(Node):\r\n    def __init__(self):\r\n        super().__init__(\'adaptive_costmap\')\r\n        \r\n        # Parameters\r\n        self.base_resolution = 0.05  # meters per cell\r\n        self.max_resolution = 0.2    # When robot is moving fast\r\n        self.min_resolution = 0.02   # When robot is careful\r\n        \r\n        # Robot state\r\n        self.current_speed = 0.0\r\n        self.is_in_narrow_space = False\r\n        self.is_approaching_obstacle = False\r\n        \r\n        # Timer to update costmap resolution\r\n        self.resolution_timer = self.create_timer(0.5, self.update_resolution)\r\n    \r\n    def update_resolution(self):\r\n        """Dynamically update costmap resolution based on situation"""\r\n        # Determine appropriate resolution\r\n        resolution = self.base_resolution\r\n        \r\n        # Increase resolution when moving fast\r\n        if self.current_speed > 0.3:\r\n            resolution = min(self.max_resolution, resolution * 2)\r\n        \r\n        # Increase resolution in narrow spaces\r\n        if self.is_in_narrow_space:\r\n            resolution = self.min_resolution\r\n        \r\n        # Increase resolution when approaching obstacles\r\n        if self.is_approaching_obstacle:\r\n            resolution = self.min_resolution\r\n        \r\n        # Apply new resolution to costmaps\r\n        self.apply_costmap_resolution(resolution)\r\n    \r\n    def apply_costmap_resolution(self, resolution):\r\n        """Apply resolution to costmap servers"""\r\n        # This would typically call services to update costmap parameters\r\n        pass\n'})}),"\n",(0,o.jsx)(r.p,{children:"Nav2 provides the foundation for sophisticated humanoid navigation, enabling these robots to operate safely and efficiently in complex environments. By customizing Nav2 for the specific requirements of humanoid robots, including balance considerations and bipedal locomotion, developers can create navigation systems that are both effective and safe for human-robot interaction."})]})}function p(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);