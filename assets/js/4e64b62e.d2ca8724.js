"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[7443],{8453:(e,o,i)=>{i.d(o,{R:()=>l,x:()=>r});var n=i(6540);const t={},s=n.createContext(t);function l(e){const o=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),n.createElement(s.Provider,{value:o},e.children)}},8901:(e,o,i)=>{i.r(o),i.d(o,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"module-2-digital-twin/complete-humanoid-simulation","title":"5. Building a Complete Humanoid Simulation","description":"We\'ve learned about physics in Gazebo, rendering in Unity, and simulating sensors. Now it\'s time to assemble all these components into a complete, end-to-end digital twin of our humanoid robot.","source":"@site/docs/module-2-digital-twin/5-complete-humanoid-simulation.md","sourceDirName":"module-2-digital-twin","slug":"/module-2-digital-twin/complete-humanoid-simulation","permalink":"/physical-ai-book/docs/module-2-digital-twin/complete-humanoid-simulation","draft":false,"unlisted":false,"editUrl":"https://github.com/physical-ai-book/physical-ai-book/tree/main/docs/module-2-digital-twin/5-complete-humanoid-simulation.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"5. Building a Complete Humanoid Simulation","sidebar_label":"Complete Humanoid Simulation","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Simulation","permalink":"/physical-ai-book/docs/module-2-digital-twin/sensor-simulation"},"next":{"title":"Exercises","permalink":"/physical-ai-book/docs/module-2-digital-twin/exercises"}}');var t=i(4848),s=i(8453);const l={title:"5. Building a Complete Humanoid Simulation",sidebar_label:"Complete Humanoid Simulation",sidebar_position:5},r="5. Building a Complete Humanoid Simulation",a={},c=[{value:"The Full Architecture",id:"the-full-architecture",level:2},{value:"Breakdown of the Loop:",id:"breakdown-of-the-loop",level:3},{value:"The Importance of <code>ros2_control</code>",id:"the-importance-of-ros2_control",level:2},{value:"The Power of Launch Files",id:"the-power-of-launch-files",level:2}];function d(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"5-building-a-complete-humanoid-simulation",children:"5. Building a Complete Humanoid Simulation"})}),"\n",(0,t.jsx)(o.p,{children:"We've learned about physics in Gazebo, rendering in Unity, and simulating sensors. Now it's time to assemble all these components into a complete, end-to-end digital twin of our humanoid robot."}),"\n",(0,t.jsxs)(o.p,{children:["Our goal is to create a simulation that is fully controlled and monitored through ROS 2. An AI agent should be able to send commands and receive sensor data from the simulated robot, just as it would with the physical hardware. This is called creating a ",(0,t.jsx)(o.strong,{children:"closed-loop simulation"}),"."]}),"\n",(0,t.jsx)(o.h2,{id:"the-full-architecture",children:"The Full Architecture"}),"\n",(0,t.jsx)(o.p,{children:"Let's look at the complete architecture of our digital twin setup, using Gazebo as the simulator."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-mermaid",children:'graph TD\n    subgraph "ROS 2 World"\n        A[AI Agent / Controller Node]\n        D[Perception / SLAM Node]\n        F[RViz]\n    end\n\n    subgraph "Gazebo World"\n        B(Physics & World Simulation)\n        C(Robot Model with Plugins)\n    end\n    \n    A -- /follow_joint_trajectory (Action) --\x3e C;\n    C -- Joint States --\x3e B;\n    B -- Simulated Sensor Data --\x3e E{ROS 2 Topics};\n    E -- /scan, /imu, /camera/image_raw --\x3e D;\n    B -- TF2 Transforms --\x3e E;\n    E -- /tf, /tf_static --\x3e F;\n    E -- /scan, /map --\x3e F;\n'})}),"\n",(0,t.jsx)(o.h3,{id:"breakdown-of-the-loop",children:"Breakdown of the Loop:"}),"\n",(0,t.jsxs)(o.ol,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Control"}),': Our AI agent (for now, a simple Python node) decides on an action, like "wave the arm." It sends this command as a goal to the ',(0,t.jsx)(o.code,{children:"/follow_joint_trajectory"})," action server."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Simulation"}),": A ",(0,t.jsx)(o.code,{children:"ros2_control"})," plugin within Gazebo receives this goal. It uses Gazebo's physics engine to calculate how the robot's joints should move to achieve the trajectory."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"State Feedback"}),": The Gazebo simulator constantly updates the state of the robot model."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Sensor Publication"}),": The sensor plugins we attached to our robot model (cameras, LiDAR, IMU) render the simulated world from their perspective and publish the results to ROS 2 topics like ",(0,t.jsx)(o.code,{children:"/scan"})," and ",(0,t.jsx)(o.code,{children:"/camera/image_raw"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Transform Publication"}),": The ",(0,t.jsx)(o.code,{children:"ros2_control"})," plugin also publishes the real-time position of all the robot's links to the ",(0,t.jsx)(o.code,{children:"/tf"})," topic."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Perception"}),": A perception or SLAM (Simultaneous Localization and Mapping) node subscribes to the sensor and TF topics to build a map of the environment or detect objects."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.strong,{children:"Visualization"}),": RViz subscribes to ",(0,t.jsx)(o.code,{children:"/tf"}),", ",(0,t.jsx)(o.code,{children:"/map"}),", ",(0,t.jsx)(o.code,{children:"/scan"}),", and other topics to provide a real-time 3D visualization of what the robot is \"thinking.\" It shows the robot's position, the map it's building, and the sensor data it's receiving."]}),"\n"]}),"\n",(0,t.jsx)(o.p,{children:"This entire system runs on your computer. You can write code, run your simulation, and debug your algorithms, all without needing a physical robot."}),"\n",(0,t.jsxs)(o.h2,{id:"the-importance-of-ros2_control",children:["The Importance of ",(0,t.jsx)(o.code,{children:"ros2_control"})]}),"\n",(0,t.jsxs)(o.p,{children:["In Module 1, we published directly to ",(0,t.jsx)(o.code,{children:"/joint_states"})," to control our robot in RViz. This is a simple approach that works for visualization, but it's not how real robots (or high-fidelity simulations) are controlled."]}),"\n",(0,t.jsxs)(o.p,{children:["For a more realistic simulation, we use the ",(0,t.jsx)(o.strong,{children:(0,t.jsx)(o.code,{children:"ros2_control"})})," framework. ",(0,t.jsx)(o.code,{children:"ros2_control"})," is a standard and generalized way to interface with robot hardware. By adding the ",(0,t.jsx)(o.code,{children:"ros2_control"})," Gazebo plugin to our robot's description, we get a much more powerful and realistic interface."]}),"\n",(0,t.jsxs)(o.p,{children:["Instead of just publishing a target position, ",(0,t.jsx)(o.code,{children:"ros2_control"})," allows us to use sophisticated controllers, such as a ",(0,t.jsx)(o.code,{children:"joint_trajectory_controller"}),". This controller:"]}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["Exposes a ",(0,t.jsx)(o.code,{children:"FollowJointTrajectory"})," action server."]}),"\n",(0,t.jsx)(o.li,{children:"Accepts a goal containing a sequence of points with positions, velocities, and accelerations."}),"\n",(0,t.jsx)(o.li,{children:"Runs a PID (Proportional-Integral-Derivative) control loop inside the simulator to ensure the robot's joints follow the trajectory accurately."}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["This is much closer to how a real robot arm works. Your high-level AI agent simply needs to provide a target trajectory, and ",(0,t.jsx)(o.code,{children:"ros2_control"})," handles the low-level work of making the joints follow it."]}),"\n",(0,t.jsx)(o.h2,{id:"the-power-of-launch-files",children:"The Power of Launch Files"}),"\n",(0,t.jsx)(o.p,{children:"As you can see, our system now has many moving parts:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"The Gazebo simulator itself."}),"\n",(0,t.jsx)(o.li,{children:"A node to spawn the robot model."}),"\n",(0,t.jsxs)(o.li,{children:["The ",(0,t.jsx)(o.code,{children:"robot_state_publisher"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:["The ",(0,t.jsx)(o.code,{children:"joint_state_broadcaster"})," (part of ",(0,t.jsx)(o.code,{children:"ros2_control"}),")."]}),"\n",(0,t.jsxs)(o.li,{children:["The ",(0,t.jsx)(o.code,{children:"joint_trajectory_controller"})," (part of ",(0,t.jsx)(o.code,{children:"ros2_control"}),")."]}),"\n",(0,t.jsx)(o.li,{children:"Our own AI agent / controller nodes."}),"\n",(0,t.jsx)(o.li,{children:"RViz for visualization."}),"\n"]}),"\n",(0,t.jsxs)(o.p,{children:["Starting all of these manually in separate terminals would be tedious and error-prone. This is why we use ",(0,t.jsx)(o.strong,{children:"ROS 2 launch files"}),". A launch file is a Python script that lets you define all the nodes you want to run, their parameters, and their configurations, and then start them all with a single command:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-bash",children:"ros2 launch my_robot_simulation full_simulation.launch.py\n"})}),"\n",(0,t.jsx)(o.p,{children:"This single command can bring up your entire digital twin environment, ready for testing."}),"\n",(0,t.jsx)(o.p,{children:"In the exercises, we will provide a complete launch file that starts a Gazebo world, spawns our humanoid, and gets it ready to receive commands. This complete, closed-loop simulation will be the foundation for everything we build in the rest of this textbook."})]})}function h(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);